<!DOCTYPE html> <html>
	<head>
	<title></title>
	<meta charset="utf-8">
	<meta http-equiv="cache-control" content="max-age=0">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">
	<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT">
	<meta http-equiv="pragma" content="no-cache">

	</head>

	<body>
		<div id="WebGL-output"></div>
		<div id="Stats-output"></div>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.js"> </script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r14/Stats.js"></script>
		<script type="text/javascript">
			function init(){

				var width = window.innerWidth;
				var height = window.innerHeight;

				var gui = new dat.GUI();

				var controls = new function(){

					this.clone = function(){
						scene.remove(clonedCubeGroup);


						var clonedCubeGeometry = cubeGroup.children[0].geometry.clone();

						var materials = [
								new THREE.MeshLambertMaterial({opacity: 0.6, color: 0xff2200, transparent: true}),
								new THREE.MeshBasicMaterial({color: 0x000000, wireframe: true})
						];

						var clonedCubeGroup = THREE.SceneUtils.createMultiMaterialObject(clonedCubeGeometry, materials);

						clonedCubeGroup.children.forEach(function(cube){
							cube.castShadow = true;
						});

						clonedCubeGroup.translateX(5);
						clonedCubeGroup.translateZ(5);
						scene.add(clonedCubeGroup);
					}

					this.lightIntensity = 1;

				}

				gui.add(controls, 'clone');
				gui.add(controls, 'lightIntensity', 0, 14, 1);


				var stats = initStats();

				var scene = new THREE.Scene();

				var renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(new THREE.Color(0xffffff, 1.0));
				renderer.setSize(width,height);
				renderer.shadowMapEnabled = true;

				var axes = new THREE.AxisHelper(20);
				scene.add(axes);

				var spotLight = new THREE.SpotLight(0xffffff);
				spotLight.position.set(-50, 75, -50);
				spotLight.castShadow = true;
				scene.add(spotLight);

				var planeGeometry = new THREE.PlaneBufferGeometry(60, 40, 1, 1);
				var planeMaterial = new THREE.MeshLambertMaterial({color: 0x335577});
				var plane = new THREE.Mesh(planeGeometry, planeMaterial);
			  plane.receiveShadow = true;
			  plane.position.set(0, 0, 0);
		 	  plane.rotation.x = -0.5 * Math.PI;
				scene.add(plane);

				var camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
				camera.position.set(-15, 17, 12);
				camera.lookAt(new THREE.Vector3(4, 0, 0));
				scene.add(camera);

				function newVerticies(){

					var array = [];
					for(var x = 0; x < 3; x++){
						array.push(
							new THREE.Vector3(1,3,1),		//0
							new THREE.Vector3(1,3,-1),	//1
							new THREE.Vector3(1,-1,1),	//2
							new THREE.Vector3(1,-1,-1),	//3
							new THREE.Vector3(-1,3,-1),	//4
							new THREE.Vector3(-1,3,1),	//5
							new THREE.Vector3(-1,-1,-1),	//6
							new THREE.Vector3(-1,-1,1)	//7
						);
					}
					return array;
				}



				// function newFaces(){
				//
				// 	var array = [];
				// 	for(var x = 0; x < 3; x++){
				// 		var n = x * 8;
				// 		array.push(
				// 			//0-3
				// 			new THREE.Face3(0+n,2+n,1+n),
				// 			new THREE.Face3(2+n,3+n,1+n),
				// 			//4-7
				// 			new THREE.Face3(4+n,6+n,5+n),
				// 			new THREE.Face3(6+n,7+n,5+n)
				// 		);
				// 	}
				// 	return array;
				// }


				var vertices = newVerticies();
				console.log("vertices:" + JSON.stringify(vertices));


				var groupSize = 8;

				var faces = [
					//0-3
					new THREE.Face3(0,2,1),
					new THREE.Face3(2,3,1),
					//4-7
					new THREE.Face3(4,6,5),
					new THREE.Face3(6,7,5),

					new THREE.Face3(4 + groupSize,5 + groupSize,1 + groupSize),
					new THREE.Face3(5 + groupSize,0 + groupSize,1 + groupSize),

					new THREE.Face3(7 + groupSize,6 + groupSize,2 + groupSize),
					new THREE.Face3(6 + groupSize,3 + groupSize,2 + groupSize),

					new THREE.Face3(5 + groupSize * 2,7 + groupSize * 2,0 + groupSize * 2),
					new THREE.Face3(7 + groupSize * 2,2 + groupSize * 2,0 + groupSize * 2) ,

					new THREE.Face3(1 + groupSize * 2,3 + groupSize * 2,4 + groupSize * 2),
					new THREE.Face3(3 + groupSize * 2,6 + groupSize * 2,4 + groupSize * 2)
				];

				var cubeGeometry = new THREE.Geometry();

				cubeGeometry.vertices = vertices;
				cubeGeometry.faces = faces;
				cubeGeometry.computeFaceNormals();

				var materials = [
						new THREE.MeshLambertMaterial({opacity: 0.6, color: 0x44ff44, transparent: true}),
						new THREE.MeshBasicMaterial({color: 0x000000, wireframe: true})
				];

				var cubeGroup = new THREE.SceneUtils.createMultiMaterialObject(cubeGeometry, materials);

				cubeGroup.children.forEach(function (cube) {
						cube.castShadow = true;
						cube.position.x += 4;
				});

				scene.add(cubeGroup);

				document.getElementById("WebGL-output").appendChild(renderer.domElement);
				render();

				// function addCube() {
				//
				// }

				function render() {
						stats.update();

						spotLight.intensity = (controls.lightIntensity/2);

						// var vertices = [];
						// for (var i = 0; i < 8; i++) {
						// 		// vertices.push(new THREE.Vector3(controlPoints[i].x, controlPoints[i].y, controlPoints[i].z));
						// }

						cubeGroup.children.forEach( function(cube) {
							cube.geometry.vertices = vertices;
							cube.geometry.verticesNeedUpdate = true;
							cube.geometry.computeFaceNormals();
						});

						requestAnimationFrame(render);
						renderer.render(scene, camera);
				}

				function initStats() {

						var stats = new Stats();

						stats.setMode(0); // 0: fps, 1: ms

						// Align top-left
						stats.domElement.style.position = 'absolute';
						stats.domElement.style.left = '0px';
						stats.domElement.style.top = '0px';

						document.getElementById("Stats-output").appendChild(stats.domElement);

						return stats;
				}

			};
			window.onload = init;

		</script>

	</body>
</html>
