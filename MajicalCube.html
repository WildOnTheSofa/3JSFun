<!DOCTYPE html> <html>
	<head>
	<title></title>
	<meta charset="utf-8">
	<meta http-equiv="cache-control" content="max-age=0">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">
	<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT">
	<meta http-equiv="pragma" content="no-cache">

	</head>

	<body>
		<div id="WebGL-output"></div>
		<div id="Stats-output"></div>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.js"> </script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r14/Stats.js"></script>
		<script type="text/javascript">
			function init(){

				var width = window.innerWidth;
				var height = window.innerHeight;

				var stats = initStats();

				var scene = new THREE.Scene();

				var renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(new THREE.Color(0xffffff, 1.0));
				renderer.setSize(width,height);
				renderer.shadowMapEnabled = true;

				var axes = new THREE.AxisHelper(20);
				scene.add(axes);

				var spotLight = new THREE.SpotLight(0xff11ff);
				spotLight.position.set(-40, 60, 10);
				spotLight.castShadow = true;
				scene.add(spotLight);

				// var planeGeometry = new THREE.PlaneBufferGeometry(60, 40, 1, 1);
				// var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
				// var plane = new THREE.Mesh(planeGeometry, planeMaterial);
				// plane.receiveShadow = true;
				// plane.position.set(0, 0, 0);
				// plane.rotation.x = -0.5 * Math.PI;
				// scene.add(plane);

				var camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
				camera.position.set(-10, 10, 10);
				camera.lookAt(new THREE.Vector3(5, 0, 0));
				scene.add(camera);

				function newVerticies(){

					var array = [];
					for(var x = 0; x < 3; x++){
						array.push(
							new THREE.Vector3(1,3,1),		//0
							new THREE.Vector3(1,3,-1),	//1
							new THREE.Vector3(1,-1,1),	//2
							new THREE.Vector3(1,-1,-1),	//3
							new THREE.Vector3(-1,3,-1),	//4
							new THREE.Vector3(-1,3,1),	//5
							new THREE.Vector3(-1,-1,-1),	//6
							new THREE.Vector3(-1,-1,1)	//7
						);
					}
					return array;
				}



				// function newFaces(){
				//
				// 	var array = [];
				// 	for(var x = 0; x < 3; x++){
				// 		var n = x * 8;
				// 		array.push(
				// 			//0-3
				// 			new THREE.Face3(0+n,2+n,1+n),
				// 			new THREE.Face3(2+n,3+n,1+n),
				// 			//4-7
				// 			new THREE.Face3(4+n,6+n,5+n),
				// 			new THREE.Face3(6+n,7+n,5+n)
				// 		);
				// 	}
				// 	return array;
				// }


				var vertices = newVerticies();
				var vertices2 = newVerticies();
				vertices2[3] = new THREE.Vector3(9, 9, 9);
			//	console.log("vertices:" + JSON.stringify(vertices));


				var groupSize = 8;

				var cfaces = [
					//0-3
					new THREE.Face3(0,2,1),
					new THREE.Face3(2,3,1),
					//4-7
					new THREE.Face3(4,6,5),
					new THREE.Face3(6,7,5),

					new THREE.Face3(4 + groupSize,5 + groupSize,1 + groupSize),
					new THREE.Face3(5 + groupSize,0 + groupSize,1 + groupSize),

					new THREE.Face3(7 + groupSize,6 + groupSize,2 + groupSize),
					new THREE.Face3(6 + groupSize,3 + groupSize,2 + groupSize),

					new THREE.Face3(5 + groupSize * 2,7 + groupSize * 2,0 + groupSize * 2),
					new THREE.Face3(7 + groupSize * 2,2 + groupSize * 2,0 + groupSize * 2) ,

					new THREE.Face3(1 + groupSize * 2,3 + groupSize * 2,4 + groupSize * 2),
					new THREE.Face3(3 + groupSize * 2,6 + groupSize * 2,4 + groupSize * 2)
				];

				var geom = new THREE.Geometry();

				geom.vertices = vertices2;
				//
				 geom.faces = cfaces;
				 geom.computeFaceNormals();
				// console.log("geom:" + JSON.stringify(geom));



				var cube = new THREE.Mesh(geom, new THREE.MeshLambertMaterial({color: 0xff0000}));

				console.log("cube.children:" +  JSON.stringify(cube.children));


				cube.position.z += 5;
				scene.add(cube);
				//cube.children.forEach(function (face) {
					 cube.geometry.vertices = vertices;
					 console.log("face vertices:" + JSON.stringify(cube.geometry.vertices));
					 console.log("vertices:" + JSON.stringify(vertices));
					 cube.geometry.verticesNeedUpdate = true;
					 cube.geometry.computeFaceNormals();
			//	});

				document.getElementById("WebGL-output").appendChild(renderer.domElement);
				render();

				// function addCube() {
				//
				// }

				function render() {
						stats.update();

						// var vertices = [];
						// for (var i = 0; i < 8; i++) {
						// 		// vertices.push(new THREE.Vector3(controlPoints[i].x, controlPoints[i].y, controlPoints[i].z));
						// }



						requestAnimationFrame(render);
						renderer.render(scene, camera);
				}

				function initStats() {

						var stats = new Stats();

						stats.setMode(0); // 0: fps, 1: ms

						// Align top-left
						stats.domElement.style.position = 'absolute';
						stats.domElement.style.left = '0px';
						stats.domElement.style.top = '0px';

						document.getElementById("Stats-output").appendChild(stats.domElement);

						return stats;
				}

			};
			window.onload = init;

		</script>

	</body>
</html>
