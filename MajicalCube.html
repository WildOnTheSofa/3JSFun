<!DOCTYPE html> <html>
	<head>
	<title></title>
	<meta charset="utf-8">
	<meta http-equiv="cache-control" content="max-age=0">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">
	<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT">
	<meta http-equiv="pragma" content="no-cache">

	</head>

	<body>
		<div id="WebGL-output"></div>
		<div id="Stats-output"></div>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.js"> </script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r14/Stats.js"></script>
		<script type="text/javascript">
			function init(){
				var width = window.innerWidth;
				var height = window.innerHeight;

				var stats = initStats();

				var scene = new THREE.Scene();

				var renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(new THREE.Color(0xff0000, 1.0));
				renderer.setSize(width,height);
				renderer.shadowMapEnabled = true;


				var spotLight = new THREE.SpotLight(0xff11ff);
				spotLight.position.set(-40, 60, 10);
				spotLight.castShadow = true;
				scene.add(spotLight);

				var planeGeometry = new THREE.PlaneBufferGeometry(60, 40, 1, 1);
				var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
				var plane = new THREE.Mesh(planeGeometry, planeMaterial);
				plane.receiveShadow = true;
				plane.position.set(0, 0, 0);
				plane.rotation.x = -0.5 * Math.PI;
				scene.add(plane);

				var camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
				camera.position.set(-20, 25, 20);
				camera.lookAt(new THREE.Vector3(5, 0, 0));
				scene.add(camera);


				function initVertices(code){
					if(code == 1){
						return [
							new THREE.Vector3(1, 3, 1),
							new THREE.Vector3(1, 3, -1),
							new THREE.Vector3(1, -1, 1),
							new THREE.Vector3(-1, 3, -1)
						];
					}

					if(code == 2){
						return [
							new THREE.Vector3(-1, 3, -1),
							new THREE.Vector3(-1, 3, 1),
							new THREE.Vector3(-1, -1, -1),
							new THREE.Vector3(-1, -1, 1)
						];
					}

					if(code == 3){
						return [
							new THREE.Vector3(1, 3, 1),
							new THREE.Vector3(1, 3, -1),
							new THREE.Vector3(-1, 3, -1),
							new THREE.Vector3(-1, 3, 1)
						];
					}

					if(code == 4){
						return[
							new THREE.Vector3(1, -1, 1),
							new THREE.Vector3(1, -1, -1),
							new THREE.Vector3(-1, -1, -1),
							new THREE.Vector3(-1, -1, 1)
						];
					}

					if(code == 5){
						return[
							new THREE.Vector3(1, 3, 1),
							new THREE.Vector3(1, -1, 1),
							new THREE.Vector3(-1, 3, 1),
							new THREE.Vector3(-1, -1, 1)
						];
					}

					if(code == 6){
						return[
							new THREE.Vector3(1, 3, -1),
							new THREE.Vector3(1, -1, -1),
							new THREE.Vector3(-1, 3, -1),
							new THREE.Vector3(-1, -1, -1)
						];
					}

				}

				var faces = [new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1)];

				function getSquares(code, squares){


					if(code < 1){
						console.log("squares:" + squares);
						return;
					}

					var x = new THREE.Geometry();
					x.vertices = initVertices(code);
					x.faces = faces;
					squares.push(x);

					getSquares((code - 1), squares);
				}

				function mergeSquares(x, y){
					for(var n = 0; n < 6; n++){
						//x[n].updateMatrix();
						var g = x[n];
						// console.log("is a Geom" + (g instanceof THREE.Geometry));
						y.merge(x[n]);
						// console.log(y);
					}

					return y;
				}

				var squares = [];
				getSquares(6,squares);
				console.log("squares result:" + squares);


				var cubeGeometry = mergeSquares(squares, new THREE.Geometry() );
				cubeGeometry.computeFaceNormals();
				var cube = new THREE.Mesh(cube, new THREE.MeshLambertMaterial({color: 0xffffff}));

				//scene.add(cube);

				var cvertices = [
					new THREE.Vector3(1,3,1),
					new THREE.Vector3(1,3,-1),
					new THREE.Vector3(1,-1,1),
					new THREE.Vector3(1,-1,-1),
					new THREE.Vector3(-1,3,-1),
					new THREE.Vector3(-1,3,1),
					new THREE.Vector3(-1,-1,-1),
					new THREE.Vector3(-1,-1,1)
				];

				var cfaces = [
					new THREE.Face3(0,2,1),
					new THREE.Face3(2,3,1),
					new THREE.Face3(4,6,5),
					new THREE.Face3(6,7,5),
					new THREE.Face3(4,5,1),
					new THREE.Face3(5,0,1),
					new THREE.Face3(7,6,2),
					new THREE.Face3(6,3,2),
					new THREE.Face3(5,7,0),
					new THREE.Face3(7,2,0),
					new THREE.Face3(1,3,4),
					new THREE.Face3(3,6,4)
				];

				var cgeom = new THREE.Geometry();
				cgeom.vertices = cvertices;
				cgeom.faces = cfaces;
				cgeom.computeFaceNormals();

				

				document.getElementById("WebGL-output").appendChild(renderer.domElement);
				render();

				// function addCube() {
				//
				// }

				function render() {
						stats.update();

						// var vertices = [];
						// for (var i = 0; i < 8; i++) {
						// 		// vertices.push(new THREE.Vector3(controlPoints[i].x, controlPoints[i].y, controlPoints[i].z));
						// }

						// mesh.children.forEach(function (e) {
						// 		e.geometry.vertices = vertices;
						// 		e.geometry.verticesNeedUpdate = true;
						// 		e.geometry.computeFaceNormals();
						// });

						requestAnimationFrame(render);
						renderer.render(scene, camera);
				}

				function initStats() {

						var stats = new Stats();

						stats.setMode(0); // 0: fps, 1: ms

						// Align top-left
						stats.domElement.style.position = 'absolute';
						stats.domElement.style.left = '0px';
						stats.domElement.style.top = '0px';

						document.getElementById("Stats-output").appendChild(stats.domElement);

						return stats;
				}

			};
			window.onload = init;

		</script>

	</body>
</html>
