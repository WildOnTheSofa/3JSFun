<!DOCTYPE html> <html>
	<head>
	<title></title>
	<meta charset="utf-8">
	<meta http-equiv="cache-control" content="max-age=0">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">
	<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT">
	<meta http-equiv="pragma" content="no-cache">

	</head>

	<body>
		<div id="WebGL-output"></div>
		<div id="Stats-output"></div>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.js"> </script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r14/Stats.js"></script>
		<script type="text/javascript">
			function init(){
				var width = window.innerWidth;
				var height = window.innerHeight;

				var stats = initStats();

				var scene = new THREE.Scene();

				var renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(new THREE.Color(0xff0000, 1.0));
				renderer.setSize(width,height);
				renderer.shadowMapEnabled = true;
				renderer.setClearColor(new THREE.Color(0xff0000, 1.0));

				var spotLight = new THREE.SpotLight(0xff11ff);
				spotLight.position.set(-40, 60, 10);
				spotLight.castShadow = true;
				scene.add(spotLight);

				var planeGeometry = new THREE.PlaneBufferGeometry(60, 40, 1, 1);
				var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
				var plane = new THREE.Mesh(planeGeometry, planeMaterial);
				plane.receiveShadow = true;
				plane.position.set(0, 0, 0);
				plane.rotation.x = -0.5 * Math.PI;
				scene.add(plane);

				var camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
				camera.position.set(-20, 25, 20);
				camera.lookAt(new THREE.Vector3(5, 0, 0));
				scene.add(camera);

				function initVertices(code){
					if(code == 1){
						return [
							new THREE.Vector3(1, 3, 1),
							new THREE.Vector3(1, 3, -1),
							new THREE.Vector3(1, -1, 1),
							new THREE.Vector3(-1, 3, -1)
						];
					}

					if(code == 2){
						return [
							new THREE.Vector3(-1, 3, -1),
							new THREE.Vector3(-1, 3, 1),
							new THREE.Vector3(-1, -1, -1),
							new THREE.Vector3(-1, -1, 1)
						];
					}

					if(code == 3){
						return [
							new THREE.Vector3(1, 3, 1),
							new THREE.Vector3(1, 3, -1),
							new THREE.Vector3(-1, 3, -1),
							new THREE.Vector3(-1, 3, 1)
						];
					}

					if(code == 4){
						return[
							new THREE.Vector3(1, -1, 1),
							new THREE.Vector3(1, -1, -1),
							new THREE.Vector3(-1, -1, -1),
							new THREE.Vector3(-1, -1, 1)
						];
					}

					if(code == 5){
						return[
							new THREE.Vector3(1, 3, 1),
							new THREE.Vector3(1, -1, 1),
							new THREE.Vector3(-1, 3, 1),
							new THREE.Vector3(-1, -1, 1)
						];
					}

					if(code == 6){
						return[
							new THREE.Vector3(1, 3, -1),
							new THREE.Vector3(1, -1, -1),
							new THREE.Vector3(-1, 3, -1),
							new THREE.Vector3(-1, -1, -1)
						];
					}

				}

				var faces = [new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1)];

				function getSquares(code){
					squares = [];

					if(code < 1){
						return squares;
					}

					var x = new THREE.Geometry();
					x.vertices = initVertices(code);
					x.faces = faces;
					squares.push(x);

					getSquares((code - 1));
				}

				function mergeSquares(x, cube){
					console.log(x);
					if((x[0] instanceof THREE.Geometry) == false) console.log("The problematic ones are the squares stored in x."); 
					if(cube instanceof THREE.Geometry()) console.log("What is the problem?");
					else console.log("The problem's the cube.");
					THREE.GeometryUtils.merge(cube, x[0], x[1], x[2], x[3], x[4], x[5]);

					return cube;
				}

				var squares = getSquares(6);
				console.log(squares);
				var cube = mergeSquares(squares, new THREE.Geometry() );
				scene.add(cube);

				render();

				// function addCube() {
				//
				// }

				function render() {
						stats.update();

						var vertices = [];
						for (var i = 0; i < 8; i++) {
								// vertices.push(new THREE.Vector3(controlPoints[i].x, controlPoints[i].y, controlPoints[i].z));
						}

						// mesh.children.forEach(function (e) {
						// 		e.geometry.vertices = vertices;
						// 		e.geometry.verticesNeedUpdate = true;
						// 		e.geometry.computeFaceNormals();
						// });

						requestAnimationFrame(render);
						renderer.render(scene, camera);
				}

				function initStats() {

						var stats = new Stats();

						stats.setMode(0); // 0: fps, 1: ms

						// Align top-left
						stats.domElement.style.position = 'absolute';
						stats.domElement.style.left = '0px';
						stats.domElement.style.top = '0px';

						document.getElementById("Stats-output").appendChild(stats.domElement);

						return stats;
				}

			};
			window.onload = init;

		</script>

	</body>
</html>
